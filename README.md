# DesignPattern
1.创建型模式
(1).单例模式（Singleton）
确保一个类只有一个实例，并提供一个全局访问点。
示例：配置管理类、日志类。

(2).工厂方法模式（Factory Method）
定义一个用于创建对象的接口，但由子类决定实例化哪一个类。
示例：数据库连接创建器。

(3).抽象工厂模式（Abstract Factory）
提供一个创建一系列相关或依赖对象的接口，而无需指定它们的具体类。
示例：跨平台的GUI工具包。

(4).建造者模式（Builder）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
示例：HTML生成器、复杂文档生成器。

(5).原型模式（Prototype）
通过复制现有对象来创建新对象，而不是通过实例化类。
示例：对象克隆功能。

2.结构型模式
适配器模式（Adapter）
将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。
示例：连接不同API的桥梁。

(6).桥接模式（Bridge）
将抽象部分与实现部分分离，使它们可以独立变化。
示例：图形绘制系统中的形状与渲染方式分离。

(7).组合模式（Composite）
将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端可以一致地处理单个对象和组合对象。
示例：文件系统中的文件和文件夹。

(8).装饰器模式（Decorator）
动态地给对象添加新的功能，而不改变其结构。
示例：流式输入输出类。

(9).外观模式（Facade）
提供一个统一的接口，用来访问子系统中的一群接口，从而简化客户端对子系统的使用。
示例：编译器的外观类。

(10).享元模式（Flyweight）
运用共享技术有效地支持大量细粒度的对象。
示例：字符处理、对象池。

(11).代理模式（Proxy）
为其他对象提供一种代理以控制对这个对象的访问。
示例：虚代理、保护代理。

3.行为型模式
(12)责任链模式（Chain of Responsibility）
将请求沿着处理链传递，直到有对象处理它。
示例：日志记录器、事件处理链。

(13).命令模式（Command）
将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。
示例：事务操作、撤销功能。

(14).解释器模式（Interpreter）
为语言创建解释器，用来解释特定的语法或表达式。
示例：正则表达式解析器。

(15).迭代器模式（Iterator）
提供一种方法顺序访问一个集合中的各个元素，而不暴露其内部表示。
示例：STL迭代器。

(16).中介者模式（Mediator）
用一个中介对象封装一系列对象交互。
示例：GUI组件的交互管理。

(17).备忘录模式（Memento）
在不破坏封装的前提下，捕获并保存对象的内部状态，以便以后恢复。
示例：撤销操作。

(18).观察者模式（Observer）
定义对象间的一对多依赖，当一个对象改变状态时，其所有依赖者都会收到通知并自动更新。
示例：事件监听器、订阅-发布系统。

(19).状态模式（State）
允许对象在内部状态改变时改变其行为。
示例：线程状态、状态机。

(20).策略模式（Strategy）
定义一系列算法，将每个算法封装起来，并使它们可以互换。
示例：排序算法、加密算法。

(21).模板方法模式（Template Method）
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中实现。
示例：抽象类中的通用算法。

(22).访问者模式（Visitor）
为一个对象结构中的元素定义一个新操作，而不改变其类的定义。
示例：对象结构遍历。
